# File: .github/workflows/branch-deploy.yml
name: Branch-Based Deployment

# Add concurrency control to prevent multiple runs
concurrency:
  group: terraform-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches:
      - develop
      - uat
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy (dev, uat, prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - uat
          - prod
      application:
        description: 'Application to deploy'
        required: true
        default: 'giortech'
        type: choice
        options:
          - giortech
          - waspwallet
          - academyaxis

env:
  REGION: us-central1

jobs:
  determine-context:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      application: ${{ steps.set-app.outputs.application }}
      project_id: ${{ steps.load-config.outputs.project_id }}
      project_number: ${{ steps.load-config.outputs.project_number }}
      region: ${{ steps.load-config.outputs.region }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: false
      
      - name: Set environment based on trigger
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/uat" ]]; then
            echo "environment=uat" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi
          
          ENV=$(echo "$GITHUB_OUTPUT" | grep environment | cut -d'=' -f2)
          echo "Using environment: $ENV"
      
      - name: Set application based on trigger or repository
        id: set-app
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.application }}" != "" ]]; then
            APP_NAME="${{ github.event.inputs.application }}"
          else
            # Extract application name from repository name
            REPO_NAME="${{ github.repository }}"
            REPO_PART=$(echo $REPO_NAME | cut -d'/' -f2)
            
            if [[ "$REPO_PART" == "org-infrastructure" ]]; then
              APP_NAME="giortech"  # Default for infrastructure repo
            elif [[ "$REPO_PART" == giortech* ]]; then
              APP_NAME="giortech"
            elif [[ "$REPO_PART" == waspwallet* ]]; then
              APP_NAME="waspwallet"
            elif [[ "$REPO_PART" == academyaxis* ]]; then
              APP_NAME="academyaxis"
            else
              APP_NAME="giortech"  # Default fallback
            fi
          fi
          
          echo "application=$APP_NAME" >> $GITHUB_OUTPUT
          echo "Using application: $APP_NAME"
      
      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
      
      - name: Load configuration
        id: load-config
        run: |
          APP="${{ steps.set-app.outputs.application }}"
          ENV="${{ steps.set-env.outputs.environment }}"
          
          if [ ! -f ".github/config/project-config.yml" ]; then
            echo "::error::Configuration file not found: .github/config/project-config.yml"
            exit 1
          fi
          
          # Extract values from config file using yq
          PROJECT_ID=$(yq e ".$APP.$ENV.project_id" .github/config/project-config.yml)
          PROJECT_NUMBER=$(yq e ".$APP.$ENV.project_number" .github/config/project-config.yml)
          REGION=$(yq e ".$APP.$ENV.region" .github/config/project-config.yml)
          
          # Set outputs
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT
          echo "project_number=$PROJECT_NUMBER" >> $GITHUB_OUTPUT
          echo "region=$REGION" >> $GITHUB_OUTPUT
          
          # Debug output
          echo "Using configuration for $APP in $ENV environment:"
          echo "  Project ID: $PROJECT_ID"
          echo "  Project Number: $PROJECT_NUMBER"
          echo "  Region: $REGION"

  deploy-infrastructure:
    needs: determine-context
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    permissions:
      contents: 'read'
      id-token: 'write'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: false
      
      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: projects/${{ needs.determine-context.outputs.project_number }}/locations/global/workloadIdentityPools/github-pool/providers/github-provider
          service_account: github-actions-sa@${{ needs.determine-context.outputs.project_id }}.iam.gserviceaccount.com
      
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ needs.determine-context.outputs.project_id }}
      
      - name: Verify GCP connection
        run: |
          echo "Testing GCP connection:"
          gcloud auth list
          gcloud config list project
          
          echo "Current project info:"
          gcloud projects describe ${{ needs.determine-context.outputs.project_id }} || {
            echo "Unable to access project. Verify service account permissions."
            exit 1
          }
          
          echo "Checking and enabling required APIs:"
          gcloud services list --project=${{ needs.determine-context.outputs.project_id }} | grep -E 'cloudbuild|run|compute|storage' || {
            echo "Enabling essential services..."
            gcloud services enable run.googleapis.com cloudbuild.googleapis.com compute.googleapis.com storage.googleapis.com --project=${{ needs.determine-context.outputs.project_id }}
          }
      
      - name: Set Terraform working directory
        id: tf-dir
        run: |
          ENV_DIR="${{ needs.determine-context.outputs.environment }}"
          if [ "$ENV_DIR" = "develop" ]; then
            ENV_DIR="dev"
          fi
          
          TF_DIR="terraform/organization/${{ needs.determine-context.outputs.application }}/$ENV_DIR"
          echo "tf_dir=$TF_DIR" >> $GITHUB_OUTPUT
          
          if [ ! -d "$TF_DIR" ]; then
            echo "Warning: Directory $TF_DIR does not exist"
            mkdir -p "$TF_DIR"
            echo "Created directory: $TF_DIR"
          fi
          
          echo "Using Terraform directory: $TF_DIR"
      
      - name: Prepare Terraform Files
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}
        run: |
          # Check if main.tf exists, create if needed
          if [ ! -f "main.tf" ]; then
            echo "Creating main.tf as it doesn't exist..."
            cat > main.tf << 'EOFMAIN'
          terraform {
            required_providers {
              google = {
                source  = "hashicorp/google"
                version = "~> 4.0"
              }
            }
            backend "gcs" {}
          }

          provider "google" {
            project = var.project_id
            region  = var.region
          }

          # Basic resources for testing
          resource "google_storage_bucket" "storage" {
            name          = "${var.project_id}-bucket"
            location      = var.region
            force_destroy = true
            uniform_bucket_level_access = true
          }

          # Variables
          variable "project_id" {
            description = "The GCP project ID"
            type        = string
          }

          variable "region" {
            description = "The GCP region"
            type        = string
          }

          variable "environment" {
            description = "Environment (dev, uat, prod)"
            type        = string
          }

          # Outputs
          output "project_id" {
            value       = var.project_id
            description = "The GCP project ID"
          }

          output "bucket_name" {
            value       = google_storage_bucket.storage.name
            description = "Storage bucket name"
          }
          EOFMAIN
          else
            echo "main.tf already exists, using existing file"
          fi

          # Create terraform.tfvars with proper values
          cat > terraform.tfvars << EOF
          project_id  = "${{ needs.determine-context.outputs.project_id }}"
          region      = "${{ needs.determine-context.outputs.region }}"
          environment = "${{ needs.determine-context.outputs.environment }}"
          EOF

          echo "Created terraform.tfvars:"
          cat terraform.tfvars
      
      - name: Clean Any Existing Locks
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}
        run: |
          echo "🧹 Cleaning any existing state locks..."
          
          LOCK_FILE="gs://academyaxis-terraform-state/${{ needs.determine-context.outputs.application }}/${{ needs.determine-context.outputs.environment }}/default.tflock"
          
          # Check if lock file exists and remove it
          if gcloud storage ls "$LOCK_FILE" 2>/dev/null; then
            echo "🔒 Found existing lock file, removing it..."
            gcloud storage rm "$LOCK_FILE" || echo "Could not remove lock file"
            sleep 2
          else
            echo "✅ No lock file found"
          fi

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0    
      
      - name: Terraform Init
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}
        run: |
          # Create backend config file
          cat > backend.hcl << EOF
          bucket  = "academyaxis-terraform-state"
          prefix  = "${{ needs.determine-context.outputs.application }}/${{ needs.determine-context.outputs.environment }}"
          EOF
            
          # Initialize with backend config
          terraform init -backend-config=backend.hcl -reconfigure || {
            echo "Terraform init failed. Attempting to create state bucket..."
            gcloud storage buckets create gs://academyaxis-terraform-state --location=us-central1 --uniform-bucket-level-access || true
            
            # Try init again
            terraform init -backend-config=backend.hcl -reconfigure
          }
      
      - name: Terraform Plan
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}  # ✅ FIXED: Added missing working-directory
        run: |
          echo "🔄 Running Terraform plan..."
    
          # ✅ FIXED: Create terraform.tfvars with correct variables that match the Terraform configuration
          cat > terraform.tfvars << EOF
          project_id         = "${{ needs.determine-context.outputs.project_id }}"
          region             = "${{ needs.determine-context.outputs.region }}"
          environment        = "${{ needs.determine-context.outputs.environment }}"
          billing_account_id = "0141E4-398D5E-91A063"
          budget_amount      = 50
          create_identity_pool   = false
          create_service_account = false
          deploy_cloud_run       = false
          create_budget          = false
          container_image        = "gcr.io/google-samples/hello-app:1.0"
          EOF
    
          echo "Created terraform.tfvars:"
          cat terraform.tfvars
    
          # Run plan with variables file
          terraform plan -out=tfplan -no-color -var-file=terraform.tfvars || {
            echo "Terraform plan failed. Check for permission or configuration issues."
            exit 1
          }
    
          echo "✅ Plan completed successfully"
      
      - name: Terraform Apply
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}
        timeout-minutes: 15
        if: success()
        run: |
          echo "🚀 Applying Terraform changes..."
          
          # Check if plan file exists
          if [ ! -f "tfplan" ]; then
            echo "❌ No plan file found, cannot apply"
            exit 1
          fi
          
          terraform apply -auto-approve tfplan -no-color || {
            echo "Terraform apply failed. Check for permission or resource issues."
            exit 1
          }
          
          echo "✅ Infrastructure deployment completed successfully!"
      
      - name: Show Terraform Outputs
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}
        if: success()
        run: |
          echo "=== TERRAFORM OUTPUTS ==="
          terraform output -no-color || echo "No outputs defined"
          echo "=== END OUTPUTS ==="