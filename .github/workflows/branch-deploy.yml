# File: .github/workflows/branch-deploy.yml
name: Branch-Based Deployment

# Add concurrency control to prevent multiple runs
concurrency:
  group: terraform-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches:
      - develop
      - uat
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy (dev, uat, prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - uat
          - prod
      application:
        description: 'Application to deploy'
        required: true
        default: 'giortech'
        type: choice
        options:
          - giortech
          - waspwallet
          - academyaxis

jobs:
  determine-context:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      application: ${{ steps.set-app.outputs.application }}
      project_id: ${{ steps.load-config.outputs.project_id }}
      project_number: ${{ steps.load-config.outputs.project_number }}
      region: ${{ steps.load-config.outputs.region }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set environment based on trigger
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/uat" ]]; then
            echo "environment=uat" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi
      
      - name: Set application based on trigger or repository
        id: set-app
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            APP_NAME="${{ github.event.inputs.application }}"
          else
            REPO_NAME="${{ github.repository }}"
            REPO_PART=$(echo $REPO_NAME | cut -d'/' -f2)
              
            if [[ "$REPO_PART" == "org-infrastructure" ]]; then
              APP_NAME="giortech"
            elif [[ "$REPO_PART" == giortech* ]]; then
              APP_NAME="giortech"
            elif [[ "$REPO_PART" == waspwallet* ]]; then
              APP_NAME="waspwallet"
            elif [[ "$REPO_PART" == academyaxis* ]]; then
              APP_NAME="academyaxis"
            else
              APP_NAME=$REPO_PART
            fi
          fi
            
          echo "application=$APP_NAME" >> $GITHUB_OUTPUT
      
      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
      
      - name: Load configuration
        id: load-config
        run: |
          APP="${{ steps.set-app.outputs.application }}"
          ENV="${{ steps.set-env.outputs.environment }}"
          
          if [ ! -f ".github/config/project-config.yml" ]; then
            echo "::error::Configuration file not found: .github/config/project-config.yml"
            exit 1
          fi
          
          # Extract values from config file using yq
          PROJECT_ID=$(yq e ".$APP.$ENV.project_id" .github/config/project-config.yml)
          PROJECT_NUMBER=$(yq e ".$APP.$ENV.project_number" .github/config/project-config.yml)
          REGION=$(yq e ".$APP.$ENV.region" .github/config/project-config.yml)
          
          # Set outputs
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT
          echo "project_number=$PROJECT_NUMBER" >> $GITHUB_OUTPUT
          echo "region=$REGION" >> $GITHUB_OUTPUT
          
          # Debug output
          echo "Using configuration for $APP in $ENV environment:"
          echo "  Project ID: $PROJECT_ID"
          echo "  Project Number: $PROJECT_NUMBER"
          echo "  Region: $REGION"

  deploy-infrastructure:
    needs: determine-context
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    permissions:
      contents: 'read'
      id-token: 'write'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: projects/${{ needs.determine-context.outputs.project_number }}/locations/global/workloadIdentityPools/github-pool/providers/github-provider
          service_account: github-actions-sa@${{ needs.determine-context.outputs.project_id }}.iam.gserviceaccount.com
      
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
      
      - name: Verify authentication
        run: |
          echo "Current project: $(gcloud config get-value project)"
          echo "Current account: $(gcloud config get-value account)"
          gcloud projects describe ${{ needs.determine-context.outputs.project_id }} || echo "Project verification failed"
      
      - name: Set Terraform working directory
        id: tf-dir
        run: |
          ENV_DIR="${{ needs.determine-context.outputs.environment }}"
          if [ "$ENV_DIR" = "develop" ]; then
            ENV_DIR="dev"
          fi
          
          TF_DIR="terraform/organization/${{ needs.determine-context.outputs.application }}/$ENV_DIR"
          echo "tf_dir=$TF_DIR" >> $GITHUB_OUTPUT
          
          if [ ! -d "$TF_DIR" ]; then
            echo "Warning: Directory $TF_DIR does not exist"
            mkdir -p "$TF_DIR"
            echo "Created directory: $TF_DIR"
          fi
          
          echo "Using Terraform directory: $TF_DIR"
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0
      
      - name: Check Terraform files exist
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}
        run: |
          echo "Contents of $(pwd):"
          ls -la
          
          if [ ! -f "main.tf" ]; then
            echo "::error::main.tf not found in ${{ steps.tf-dir.outputs.tf_dir }}"
            echo "This workflow expects Terraform files to exist in the environment directory"
            exit 1
          fi
      
      - name: Clean Any Existing Locks
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}
        run: |
          echo "🧹 Cleaning any existing state locks..."
          
          LOCK_FILE="gs://academyaxis-terraform-state/giortech/dev/default.tflock"
          
          # Check if lock file exists and remove it
          if gcloud storage ls "$LOCK_FILE" 2>/dev/null; then
            echo "🔒 Found existing lock file, removing it..."
            gcloud storage rm "$LOCK_FILE" || echo "Could not remove lock file"
            sleep 2
          else
            echo "✅ No lock file found"
          fi
          
          # Also try force unlock with known problematic lock IDs
          echo "🔓 Attempting to clear any stuck locks..."
          PROBLEM_LOCKS=("1748333964556513" "1748108093205369")
          
          for lock_id in "${PROBLEM_LOCKS[@]}"; do
            echo "Trying to unlock: $lock_id"
            terraform init -reconfigure -no-color >/dev/null 2>&1 || true
            terraform force-unlock -force "$lock_id" 2>/dev/null || echo "Lock $lock_id not found or already unlocked"
          done
          
          echo "✅ Lock cleanup completed"
      
      - name: Terraform Init with State Recovery
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}
        timeout-minutes: 5
        env:
          GOOGLE_OAUTH_ACCESS_TOKEN: ${{ steps.auth.outputs.access_token }}
          TF_IN_AUTOMATION: "true"
          TF_INPUT: "false"
        run: |
          echo "Initializing Terraform in $(pwd)"
          
          # Clean local terraform files first
          rm -rf .terraform/
          rm -f .terraform.lock.hcl
          
          # Try init with timeout
          echo "Running terraform init..."
          if ! timeout 300 terraform init -reconfigure -upgrade -no-color; then
            echo "Init failed or timed out, trying alternative approach..."
            terraform init -backend=false -no-color
            terraform init -reconfigure -no-color
          fi
          
          echo "✅ Terraform initialization completed"
      
      - name: Pre-Plan Diagnostics
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}
        timeout-minutes: 3
        run: |
          echo "Running pre-plan diagnostics..."
          
          # Check Terraform version
          terraform version
          
          # Validate configuration
          echo "Validating Terraform configuration..."
          terraform validate -no-color
          
          # Check state (if it exists)
          echo "Checking existing state..."
          if terraform state list 2>/dev/null; then
            echo "Current resources in state:"
            terraform state list
          else
            echo "No existing state found"
          fi
          
          # Check for potential issues
          echo "Checking provider configuration..."
          terraform providers -no-color
          
          echo "✅ Pre-plan diagnostics completed"
      
      - name: Terraform Plan with Lock Handling
        id: tf-plan
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}
        timeout-minutes: 10
        run: |
          echo "Starting Terraform plan with automatic lock handling..."
          
          # Set Terraform to non-interactive mode
          export TF_IN_AUTOMATION=true
          export TF_INPUT=false
          
          # Function to attempt plan with retries
          attempt_plan() {
            local attempt=$1
            echo "🔄 Plan attempt $attempt/3"
            
            # Run terraform plan and capture both exit code and output
            set +e  # Don't exit on error
            terraform plan -detailed-exitcode -out=tfplan -no-color -lock-timeout=30s 2>&1 | tee plan.log
            local plan_exit=${PIPESTATUS[0]}
            set -e  # Re-enable exit on error
            
            if [ $plan_exit -eq 0 ] || [ $plan_exit -eq 2 ]; then
              echo "✅ Plan succeeded with exit code: $plan_exit"
              return 0
            else
              echo "❌ Plan failed with exit code: $plan_exit"
              
              # Check if it's specifically a lock issue
              if grep -q "Error acquiring the state lock" plan.log; then
                echo "🔒 State lock detected!"
                
                # Extract lock ID from the log
                LOCK_ID=$(grep -A 20 "Lock Info:" plan.log | grep -E "^\s*ID:" | awk '{print $2}' | head -1)
                
                if [ -n "$LOCK_ID" ] && [ "$LOCK_ID" != "" ]; then
                  echo "🔓 Attempting to force unlock with Lock ID: $LOCK_ID"
                  
                  if terraform force-unlock -force "$LOCK_ID" 2>&1; then
                    echo "✅ Force unlock completed"
                    sleep 3  # Wait for unlock to propagate
                    return 1  # Indicate retry needed
                  else
                    echo "❌ Force unlock failed"
                  fi
                  
                  # Alternative: Try removing lock file directly
                  echo "🗑️ Attempting direct lock file removal..."
                  LOCK_PATH="gs://academyaxis-terraform-state/giortech/dev/default.tflock"
                  if gcloud storage rm "$LOCK_PATH" 2>/dev/null; then
                    echo "✅ Lock file removed directly"
                    sleep 3
                    return 1  # Indicate retry needed
                  else
                    echo "❌ Could not remove lock file directly"
                  fi
                else
                  echo "❌ Could not extract lock ID from error message"
                  echo "Lock info from log:"
                  grep -A 10 "Lock Info:" plan.log || echo "No lock info found"
                fi
              else
                echo "💥 Plan failed for non-lock reasons"
                echo "Error details:"
                tail -20 plan.log
              fi
              
              return $plan_exit
            fi
          }
          
          # Try plan with up to 3 attempts
          FINAL_SUCCESS=false
          for i in {1..3}; do
            if attempt_plan $i; then
              echo "🎉 Plan succeeded on attempt $i"
              FINAL_SUCCESS=true
              break
            elif [ $? -eq 1 ]; then
              echo "🔄 Retrying plan after lock handling... (attempt $i)"
              continue
            else
              echo "💥 Plan failed permanently on attempt $i"
              break
            fi
          done
          
          if [ "$FINAL_SUCCESS" = true ]; then
            # Verify plan file was created
            if [ -f "tfplan" ]; then
              echo "📋 Plan file created successfully"
              
              # Show plan summary (first 30 lines)
              echo "=== PLAN SUMMARY ==="
              terraform show -no-color tfplan | head -30
              echo "=== END PLAN SUMMARY ==="
            else
              echo "❌ Plan appeared to succeed but no plan file was generated"
              exit 1
            fi
          else
            echo "💥 All plan attempts failed"
            echo "=== FINAL ERROR LOG ==="
            cat plan.log
            exit 1
          fi
      
      - name: Terraform Apply
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}
        timeout-minutes: 15
        if: success()
        run: |
          echo "Applying Terraform changes..."
          
          # Check if plan file exists
          if [ ! -f "tfplan" ]; then
            echo "❌ No plan file found, cannot apply"
            exit 1
          fi
          
          echo "Applying from plan file..."
          terraform apply -auto-approve tfplan -no-color
          
          echo "✅ Terraform apply completed"
      
      - name: Show Terraform Outputs
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}
        if: success()
        run: |
          echo "=== TERRAFORM OUTPUTS ==="
          terraform output -no-color || echo "No outputs defined"
          echo "=== END OUTPUTS ==="