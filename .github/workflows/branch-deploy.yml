# .github/workflows/branch-deploy.yml
name: Branch-Based Deployment

on:
  push:
    branches:
      - develop
      - uat
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy (dev, uat, prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - uat
          - prod
      application:
        description: 'Application to deploy'
        required: true
        default: 'giortech'
        type: choice
        options:
          - giortech
          - waspwallet
          - academyaxis

env:
  REGION: us-central1

jobs:
  determine-context:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      application: ${{ steps.set-app.outputs.application }}
      project_id: ${{ steps.set-project.outputs.project_id }}
    
    steps:
      - name: Set environment based on trigger
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/uat" ]]; then
            echo "environment=uat" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi
          
          echo "Using environment: ${{ steps.set-env.outputs.environment }}"
      
      - name: Set application based on trigger or repository
        id: set-app
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            APP_NAME="${{ github.event.inputs.application }}"
          else
            REPO_NAME="${{ github.repository }}"
            REPO_PART=$(echo $REPO_NAME | cut -d'/' -f2)
              
            if [[ "$REPO_PART" == "org-infrastructure" ]]; then
              APP_NAME="giortech"
            elif [[ "$REPO_PART" == giortech* ]]; then
              APP_NAME="giortech"
            elif [[ "$REPO_PART" == waspwallet* ]]; then
              APP_NAME="waspwallet"
            elif [[ "$REPO_PART" == academyaxis* ]]; then
              APP_NAME="academyaxis"
            else
              APP_NAME=$REPO_PART
            fi
          fi
            
          echo "application=$APP_NAME" >> $GITHUB_OUTPUT
          echo "Using application: $APP_NAME"
      
      - name: Set project ID
        id: set-project
        run: |
          APP="${{ steps.set-app.outputs.application }}"
          ENV="${{ steps.set-env.outputs.environment }}"
          
          PROJECT_ID="${APP}-${ENV}-project"
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT
          echo "Using project ID: $PROJECT_ID"
  
  deploy-infrastructure:
    needs: determine-context
    runs-on: ubuntu-latest
    
    permissions:
      contents: 'read'
      id-token: 'write'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Determine project number for authentication
        id: project-num
        run: |
          # Define a map of known project numbers
          declare -A PROJECT_NUMBERS
          PROJECT_NUMBERS["giortech-dev-project"]="653675374627"
          PROJECT_NUMBERS["giortech-uat-project"]="28962750525"
          PROJECT_NUMBERS["giortech-prod-project"]="371831144642"
          
          # Get project ID from context
          PROJECT_ID="${{ needs.determine-context.outputs.project_id }}"
          
          # Get project number from the map
          PROJECT_NUMBER="${PROJECT_NUMBERS[$PROJECT_ID]}"
          if [ -z "$PROJECT_NUMBER" ]; then
            echo "Project number not found in predefined map, using default"
            PROJECT_NUMBER="653675374627"  # Default to giortech-dev-project
          fi
          
          echo "number=$PROJECT_NUMBER" >> $GITHUB_OUTPUT
          echo "Using project number: $PROJECT_NUMBER"
      
      # First authenticate with Google Cloud
      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v1
        with:
          workload_identity_provider: projects/${{ steps.project-num.outputs.number }}/locations/global/workloadIdentityPools/github-pool/providers/github-provider
          service_account: github-actions-sa@${{ needs.determine-context.outputs.project_id }}.iam.gserviceaccount.com
      
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v1
      
      - name: Set Terraform working directory
        id: tf-dir
        run: |
          ENV_DIR="${{ needs.determine-context.outputs.environment }}"
          if [ "$ENV_DIR" = "develop" ]; then
            ENV_DIR="dev"
          fi
          
          TF_DIR="terraform/organization/${{ needs.determine-context.outputs.application }}/$ENV_DIR"
          echo "tf_dir=$TF_DIR" >> $GITHUB_OUTPUT
          
          if [ ! -d "$TF_DIR" ]; then
            echo "Warning: Directory $TF_DIR does not exist"
            mkdir -p "$TF_DIR"
            echo "Created directory: $TF_DIR"
          fi
          
          echo "Using Terraform directory: $TF_DIR"
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0
      
      - name: Prepare Terraform files
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}
        run: |
          # Check if directory is empty
          if [ ! "$(ls -A)" ]; then
            echo "Directory is empty, creating basic Terraform files..."
            
            # Create a basic main.tf file
            cat > main.tf << "EOFMAIN"
            terraform {
            required_providers {
            google = {
            source  = "hashicorp/google"
            version = "~> 4.0"
             }
            }
          }

          provider "google" {
          project = var.project_id
          region  = var.region
          }

          variable "project_id" {
          description = "The GCP project ID"
          type        = string
          }

          variable "region" {
          description = "The GCP region"
          type        = string
          }

          output "project_id" {
          value       = var.project_id
          description = "The GCP project ID"
          }
          EOFMAIN

            # Create variables.tf
            cat > variables.tf << "EOFVARS"
          variable "project_id" {
          description = "The GCP project ID"
          type        = string
          default     = "${{ needs.determine-context.outputs.project_id }}"
          }

          variable "region" {
          description = "The GCP region"
          type        = string
          default     = "${{ env.REGION }}"
          }
          EOFVARS
                fi
      
      - name: Terraform Init
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}
        env:
          GOOGLE_OAUTH_ACCESS_TOKEN: ${{ steps.auth.outputs.access_token }}
        run: |
          # Create a proper backend config file
          cat > backend.hcl << "EOFBACKEND"
          bucket = "academyaxis-terraform-state"
          prefix = "giortech/dev"
          EOFBACKEND
          
          # Initialize terraform with the current authentication
          terraform init -backend-config=backend.hcl -reconfigure
      
      - name: Terraform Plan
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}
        run: |
          terraform plan -out=tfplan
      
      - name: Terraform Apply
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}
        run: |
          terraform apply -auto-approve tfplan