# File: .github/workflows/app-deploy.yml
name: Deploy Application

on:
  push:
    branches:
      - develop
      - uat
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy (dev, uat, prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - uat
          - prod

env:
  REGION: us-central1

jobs:
  determine-context:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      application: ${{ steps.set-app.outputs.application }}
      project_id: ${{ steps.set-project.outputs.project_id }}
      service_name: ${{ steps.set-service.outputs.service_name }}
    
    steps:
      - name: Set environment based on branch or input
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/uat" ]]; then
            echo "environment=uat" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi
          
          echo "Using environment: ${{ steps.set-env.outputs.environment }}"
      
      - name: Set application based on repository
        id: set-app
        run: |
          # Extract application name from repository name
          # Expected format: owner/app-name or owner/app-name-suffix
          REPO_NAME="${{ github.repository }}"
          # First extract the repo part (after the /)
          REPO_PART=$(echo $REPO_NAME | cut -d'/' -f2)
          
          # Then determine application by prefix
          if [[ "$REPO_PART" == giortech* ]]; then
            APP_NAME="giortech"
          elif [[ "$REPO_PART" == waspwallet* ]]; then
            APP_NAME="waspwallet"
          elif [[ "$REPO_PART" == academyaxis* ]]; then
            APP_NAME="academyaxis"
          else
            # Default to the repository name if no match
            APP_NAME=$REPO_PART
          fi
          
          echo "application=$APP_NAME" >> $GITHUB_OUTPUT
          echo "Using application: $APP_NAME"
      
      - name: Set project ID and service name
        id: set-project
        run: |
          # Combine application and environment to form project ID
          APP="${{ steps.set-app.outputs.application }}"
          ENV="${{ steps.set-env.outputs.environment }}"
          
          PROJECT_ID="${APP}-${ENV}-project"
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT
          echo "Using project ID: $PROJECT_ID"
      
      - name: Set service name
        id: set-service
        run: |
          # Create Cloud Run service name
          APP="${{ steps.set-app.outputs.application }}"
          ENV="${{ steps.set-env.outputs.environment }}"
          
          SERVICE_NAME="${APP}-${ENV}"
          echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
          echo "Using service name: $SERVICE_NAME"
  
  get-identity:
    needs: determine-context
    runs-on: ubuntu-latest
    outputs:
      wi_provider: ${{ steps.identity.outputs.wi_provider }}
      sa_email: ${{ steps.identity.outputs.sa_email }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set Terraform working directory
        id: tf-dir
        run: |
          # Map environment name to directory name
          ENV_DIR="${{ needs.determine-context.outputs.environment }}"
          if [ "$ENV_DIR" = "develop" ]; then
            ENV_DIR="dev"
          fi
          
          TF_DIR="terraform/organization/${{ needs.determine-context.outputs.application }}/$ENV_DIR"
          echo "tf_dir=$TF_DIR" >> $GITHUB_OUTPUT
          
          # Check if directory exists
          if [ ! -d "$TF_DIR" ]; then
            echo "Error: Directory $TF_DIR does not exist"
            ls -la terraform/organization/
            if [ -d "terraform/organization/${{ needs.determine-context.outputs.application }}" ]; then
              ls -la terraform/organization/${{ needs.determine-context.outputs.application }}/
            fi
            
            # Use fallback values for Workload Identity
            PROJECT_NUM=$(gcloud projects describe ${{ needs.determine-context.outputs.project_id }} --format='value(projectNumber)')
            echo "wi_provider=projects/$PROJECT_NUM/locations/global/workloadIdentityPools/github-pool/providers/github-provider" >> $GITHUB_OUTPUT
            echo "sa_email=github-actions-sa@${{ needs.determine-context.outputs.project_id }}.iam.gserviceaccount.com" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Using Terraform directory: $TF_DIR"
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0
      
      - name: Terraform Init
        if: steps.tf-dir.outputs.tf_dir != ''
        working-directory: ${{ steps.tf-dir.outputs.tf_dir }}
        run: terraform init
      
      - name: Get Workload Identity Provider and Service Account
        id: identity
        run: |
          if [ -d "${{ steps.tf-dir.outputs.tf_dir }}" ]; then
            cd ${{ steps.tf-dir.outputs.tf_dir }}
            
            # Get the outputs or use fallback values
            PROVIDER=$(terraform output -raw workload_identity_provider 2>/dev/null || echo "")
            SA_EMAIL=$(terraform output -raw service_account_email 2>/dev/null || echo "")
          else
            PROVIDER=""
            SA_EMAIL=""
          fi
          
          if [ -z "$PROVIDER" ] || [ -z "$SA_EMAIL" ]; then
            echo "Warning: Could not get Workload Identity Provider or Service Account from Terraform outputs"
            echo "Using fallback values based on project ID"
            PROJECT_NUM=$(gcloud projects describe ${{ needs.determine-context.outputs.project_id }} --format='value(projectNumber)')
            PROVIDER="projects/$PROJECT_NUM/locations/global/workloadIdentityPools/github-pool/providers/github-provider"
            SA_EMAIL="github-actions-sa@${{ needs.determine-context.outputs.project_id }}.iam.gserviceaccount.com"
          fi
          
          echo "wi_provider=$PROVIDER" >> $GITHUB_OUTPUT
          echo "sa_email=$SA_EMAIL" >> $GITHUB_OUTPUT
  
  build-and-deploy:
    needs: [determine-context, get-identity]
    runs-on: ubuntu-latest
    
    permissions:
      contents: 'read'
      id-token: 'write'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          workload_identity_provider: ${{ needs.get-identity.outputs.wi_provider }}
          service_account: ${{ needs.get-identity.outputs.sa_email }}
      
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v1
      
      - name: Build Container
        run: |
          echo "Building container for ${{ needs.determine-context.outputs.application }} (${{ needs.determine-context.outputs.environment }})"
          
          # Submit the build to Cloud Build
          gcloud builds submit \
            --tag gcr.io/${{ needs.determine-context.outputs.project_id }}/${{ needs.determine-context.outputs.application }}:${{ github.sha }} \
            --project=${{ needs.determine-context.outputs.project_id }} \
            .
      
      - name: Deploy to Cloud Run
        run: |
          echo "Deploying to Cloud Run: ${{ needs.determine-context.outputs.service_name }}"
          
          # Deploy the container to Cloud Run
          gcloud run deploy ${{ needs.determine-context.outputs.service_name }} \
            --project=${{ needs.determine-context.outputs.project_id }} \
            --image=gcr.io/${{ needs.determine-context.outputs.project_id }}/${{ needs.determine-context.outputs.application }}:${{ github.sha }} \
            --region=${{ env.REGION }} \
            --platform=managed \
            --allow-unauthenticated
      
      - name: Post-Deployment Tests
        run: |
          echo "Running post-deployment tests..."
          
          # Get the service URL
          SERVICE_URL=$(gcloud run services describe ${{ needs.determine-context.outputs.service_name }} \
            --project=${{ needs.determine-context.outputs.project_id }} \
            --region=${{ env.REGION }} \
            --format="get(status.url)")
          
          # Test that the service is responding
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $SERVICE_URL)
          
          echo "Service URL: $SERVICE_URL"
          echo "HTTP Status: $HTTP_STATUS"
          
          if [[ "$HTTP_STATUS" == "200" ]]; then
            echo "✅ Service is up and running"
          else
            echo "⚠️ Service returned non-200 status: $HTTP_STATUS"
            # We don't fail the workflow, as some services might return different statuses by design
          fi