# File: .github/workflows/app-deploy.yml
name: Deploy Application

on:
  push:
    branches:
      - develop
      - uat
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy (dev, uat, prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - uat
          - prod

env:
  REGION: us-central1

jobs:
  determine-context:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      application: ${{ steps.set-app.outputs.application }}
      project_id: ${{ steps.set-project.outputs.project_id }}
      service_name: ${{ steps.set-service.outputs.service_name }}
      project_number: ${{ steps.set-project-number.outputs.project_number }}
    
    steps:
      - name: Set environment based on branch or input
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/uat" ]]; then
            echo "environment=uat" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi
          
          echo "Using environment: ${{ steps.set-env.outputs.environment }}"
      
      - name: Set application based on repository
        id: set-app
        run: |
          # Extract application name from repository name
          # Expected format: owner/app-name or owner/app-name-suffix
          REPO_NAME="${{ github.repository }}"
          # First extract the repo part (after the /)
          REPO_PART=$(echo $REPO_NAME | cut -d'/' -f2)
          
          # Debugging
          echo "Repository name: $REPO_NAME"
          echo "Repository part: $REPO_PART"
          
          # Then determine application by prefix or name
          if [[ "$REPO_PART" == "org-infrastructure" ]]; then
            APP_NAME="giortech"  # Set default application for infra repo
          elif [[ "$REPO_PART" == giortech* ]]; then
            APP_NAME="giortech"
          elif [[ "$REPO_PART" == waspwallet* ]]; then
            APP_NAME="waspwallet"
          elif [[ "$REPO_PART" == academyaxis* ]]; then
            APP_NAME="academyaxis"
          else
            # Default to the repository name if no match
            APP_NAME=$REPO_PART
          fi
          
          echo "application=$APP_NAME" >> $GITHUB_OUTPUT
          echo "Using application: $APP_NAME"
      
      - name: Set project ID and service name
        id: set-project
        run: |
          # Combine application and environment to form project ID
          APP="${{ steps.set-app.outputs.application }}"
          ENV="${{ steps.set-env.outputs.environment }}"
          
          PROJECT_ID="${APP}-${ENV}-project"
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT
          echo "Using project ID: $PROJECT_ID"
      
      - name: Set service name
        id: set-service
        run: |
          # Create Cloud Run service name
          APP="${{ steps.set-app.outputs.application }}"
          ENV="${{ steps.set-env.outputs.environment }}"
          
          SERVICE_NAME="${APP}-${ENV}"
          echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
          echo "Using service name: $SERVICE_NAME"
      
      - name: Set project number for authentication
        id: set-project-number
        run: |
          # Define direct mapping with simple variables instead of arrays
          GIORTECH_DEV="653675374627"
          GIORTECH_UAT="28962750525"
          GIORTECH_PROD="371831144642"
          
          # Get project ID from previous step
          PROJECT_ID="${{ steps.set-project.outputs.project_id }}"
          echo "Checking project number for: $PROJECT_ID"
          
          # Use simple if conditions instead of arrays
          if [[ "$PROJECT_ID" == "giortech-dev-project" ]]; then
            PROJECT_NUMBER="$GIORTECH_DEV"
          elif [[ "$PROJECT_ID" == "giortech-uat-project" ]]; then
            PROJECT_NUMBER="$GIORTECH_UAT"
          elif [[ "$PROJECT_ID" == "giortech-prod-project" ]]; then
            PROJECT_NUMBER="$GIORTECH_PROD"
          else
            PROJECT_NUMBER=""
          fi
          
          # Output result
          if [[ -z "$PROJECT_NUMBER" ]]; then
            echo "Project number not found for $PROJECT_ID in predefined mapping"
            echo "project_number=unknown" >> $GITHUB_OUTPUT
          else
            echo "project_number=$PROJECT_NUMBER" >> $GITHUB_OUTPUT
            echo "Using project number: $PROJECT_NUMBER"
          fi
  
  get-identity:
    needs: determine-context
    runs-on: ubuntu-latest
    outputs:
      wi_provider: ${{ steps.identity.outputs.wi_provider }}
      sa_email: ${{ steps.identity.outputs.sa_email }}
    
    permissions:
      contents: 'read'
      id-token: 'write'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Create required directories for modules
        run: |
          # Ensure the modules directory exists
          mkdir -p terraform/modules/workload_identity
          
          # Check if the module files already exist
          if [ ! -f "terraform/modules/workload_identity/main.tf" ]; then
            echo "Creating workload_identity module files..."
            
            # Create main.tf
            cat > terraform/modules/workload_identity/main.tf << 'EOF'
# Workload Identity module for GitHub Actions

# Data source to get project number
data "google_project" "project" {
  project_id = var.project_id
}

# Create Service Account for GitHub Actions if requested
resource "google_service_account" "github_actions_sa" {
  count = var.create_service_account ? 1 : 0

  account_id   = "github-actions-sa"
  display_name = "GitHub Actions Service Account"
  project      = var.project_id
  description  = "Service account for GitHub Actions"
}
EOF
            
            # Create variables.tf
            cat > terraform/modules/workload_identity/variables.tf << 'EOF'
variable "project_id" {
  description = "The GCP project ID"
  type        = string
}

variable "github_org" {
  description = "The GitHub organization name"
  type        = string
  default     = "Giortech1"
}

variable "github_repo" {
  description = "The GitHub repository name"
  type        = string
  default     = "org-infrastructure"
}

variable "create_identity_pool" {
  description = "Whether to create the workload identity pool"
  type        = bool
  default     = true
}

variable "create_service_account" {
  description = "Whether to create the service account"
  type        = bool
  default     = true
}
EOF
            
            # Create outputs.tf
            cat > terraform/modules/workload_identity/outputs.tf << EOF
output "workload_identity_provider" {
  value       = "projects/\${data.google_project.project.number}/locations/global/workloadIdentityPools/github-pool/providers/github-provider"
  description = "Workload Identity Provider resource name for GitHub Actions"
}

output "service_account_email" {
  value       = var.create_service_account ? google_service_account.github_actions_sa[0].email : "github-actions-sa@\${var.project_id}.iam.gserviceaccount.com"
  description = "Service Account email for GitHub Actions"
}
EOF
          fi
      
      - name: Set Workload Identity values directly
        id: identity
        run: |
          PROJECT_ID="${{ needs.determine-context.outputs.project_id }}"
          PROJECT_NUMBER="${{ needs.determine-context.outputs.project_number }}"
          
          if [[ -z "$PROJECT_NUMBER" || "$PROJECT_NUMBER" == "unknown" ]]; then
            echo "Cannot determine project number. Check project mapping in workflow."
            exit 1
          fi
          
          echo "wi_provider=projects/$PROJECT_NUMBER/locations/global/workloadIdentityPools/github-pool/providers/github-provider" >> $GITHUB_OUTPUT
          echo "sa_email=github-actions-sa@$PROJECT_ID.iam.gserviceaccount.com" >> $GITHUB_OUTPUT
          
          echo "Workload Identity Provider: projects/$PROJECT_NUMBER/locations/global/workloadIdentityPools/github-pool/providers/github-provider"
          echo "Service Account: github-actions-sa@$PROJECT_ID.iam.gserviceaccount.com"
  
  build-and-deploy:
    needs: [determine-context, get-identity]
    runs-on: ubuntu-latest
    
    permissions:
      contents: 'read'
      id-token: 'write'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          workload_identity_provider: ${{ needs.get-identity.outputs.wi_provider }}
          service_account: ${{ needs.get-identity.outputs.sa_email }}
      
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v1
      
      - name: Verify GCP authentication and project
        run: |
          echo "Listing available projects:"
          gcloud projects list --limit=5
          
          echo "Current project info:"
          gcloud config get-value project
          gcloud projects describe ${{ needs.determine-context.outputs.project_id }} || echo "Project not found or not accessible"
          
          echo "Checking if required APIs are enabled:"
          gcloud services list --project=${{ needs.determine-context.outputs.project_id }} | grep -E 'cloudbuild|run|compute|storage' || echo "Some APIs may need to be enabled"
      
      - name: Build Container
        run: |
          echo "Building container for ${{ needs.determine-context.outputs.application }} (${{ needs.determine-context.outputs.environment }})"
          
          # Ensure cloudbuild API is enabled
          gcloud services enable cloudbuild.googleapis.com --project=${{ needs.determine-context.outputs.project_id }}
          
          # Check if Dockerfile exists
          if [ ! -f "Dockerfile" ]; then
            echo "Warning: Dockerfile not found at root. Using fallback image."
            echo "Skipping build step."
            echo "CONTAINER_IMAGE=gcr.io/google-samples/hello-app:1.0" >> $GITHUB_ENV
            exit 0
          fi
          
          # Submit the build to Cloud Build
          gcloud builds submit \
            --tag gcr.io/${{ needs.determine-context.outputs.project_id }}/${{ needs.determine-context.outputs.application }}:${{ github.sha }} \
            --project=${{ needs.determine-context.outputs.project_id }} \
            . || {
              echo "Build failed. Using fallback image."
              echo "CONTAINER_IMAGE=gcr.io/google-samples/hello-app:1.0" >> $GITHUB_ENV
              exit 0
            }
          
          echo "CONTAINER_IMAGE=gcr.io/${{ needs.determine-context.outputs.project_id }}/${{ needs.determine-context.outputs.application }}:${{ github.sha }}" >> $GITHUB_ENV
      
      - name: Deploy to Cloud Run
        run: |
          echo "Deploying to Cloud Run: ${{ needs.determine-context.outputs.service_name }}"
            
          # Ensure Cloud Run API is enabled
          gcloud services enable run.googleapis.com --project=${{ needs.determine-context.outputs.project_id }}
            
          # Check if service exists and create/update accordingly
          if gcloud run services describe ${{ needs.determine-context.outputs.service_name }} \
            --project=${{ needs.determine-context.outputs.project_id }} \
            --region=${{ env.REGION }} 2>/dev/null; then
              
            echo "Updating existing service"
            # For update, don't use the --allow-unauthenticated flag
            gcloud run services update ${{ needs.determine-context.outputs.service_name }} \
              --project=${{ needs.determine-context.outputs.project_id }} \
              --image=${CONTAINER_IMAGE:-gcr.io/google-samples/hello-app:1.0} \
              --region=${{ env.REGION }}
              
            # Only try to make public if not in production and if explicitly requested
            if [[ "${{ needs.determine-context.outputs.environment }}" != "prod" && "${{ github.event.inputs.make_public }}" == "true" ]]; then
              echo "Attempting to make service publicly accessible..."
              gcloud run services add-iam-policy-binding ${{ needs.determine-context.outputs.service_name }} \
                --project=${{ needs.determine-context.outputs.project_id }} \
                --region=${{ env.REGION }} \
                --member="allUsers" \
                --role="roles/run.invoker" || echo "Could not make service public - requires organization policy changes"
            fi
          else
            echo "Creating new service"
            # Deploy without public access first
            gcloud run services deploy ${{ needs.determine-context.outputs.service_name }} \
              --project=${{ needs.determine-context.outputs.project_id }} \
              --image=${CONTAINER_IMAGE:-gcr.io/google-samples/hello-app:1.0} \
              --region=${{ env.REGION }} \
              --platform=managed
              
            # Then try to make public if needed - this is likely to fail due to org policy
            if [[ "${{ needs.determine-context.outputs.environment }}" != "prod" ]]; then
              echo "Attempting to make service publicly accessible..."
              gcloud run services add-iam-policy-binding ${{ needs.determine-context.outputs.service_name }} \
                --project=${{ needs.determine-context.outputs.project_id }} \
                --region=${{ env.REGION }} \
                --member="allUsers" \
                --role="roles/run.invoker" || echo "Could not make service public - requires organization policy changes"
            fi
          fi
            
          # Output the service URL regardless of whether it's public or not
          SERVICE_URL=$(gcloud run services describe ${{ needs.determine-context.outputs.service_name }} \
            --project=${{ needs.determine-context.outputs.project_id }} \
            --region=${{ env.REGION }} \
            --format="get(status.url)")
          echo "Service URL: $SERVICE_URL"
      
      - name: Post-Deployment Tests
        run: |
          echo "Running post-deployment tests..."
          
          # Get the service URL
          SERVICE_URL=$(gcloud run services describe ${{ needs.determine-context.outputs.service_name }} \
            --project=${{ needs.determine-context.outputs.project_id }} \
            --region=${{ env.REGION }} \
            --format="get(status.url)")
          
          # Wait a moment for the service to stabilize
          sleep 10
          
          # Test that the service is responding
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $SERVICE_URL || echo "Failed to connect")
          
          echo "Service URL: $SERVICE_URL"
          echo "HTTP Status: $HTTP_STATUS"
          
          if [[ "$HTTP_STATUS" == "200" ]]; then
            echo "✅ Service is up and running"
          else
            echo "⚠️ Service returned non-200 status: $HTTP_STATUS"
            # We don't fail the workflow, as some services might return different statuses by design
          fi