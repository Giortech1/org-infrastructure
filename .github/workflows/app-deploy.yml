# .github/workflows/app-deploy.yml
name: Deploy Application

on:
  push:
    branches:
      - develop
      - uat
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy (dev, uat, prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - uat
          - prod

jobs:
  determine-context:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      application: ${{ steps.set-app.outputs.application }}
      project_id: ${{ steps.load-config.outputs.project_id }}
      project_number: ${{ steps.load-config.outputs.project_number }}
      service_name: ${{ steps.load-config.outputs.service_name }}
      region: ${{ steps.load-config.outputs.region }}
      min_instances: ${{ steps.load-config.outputs.min_instances }}
      max_instances: ${{ steps.load-config.outputs.max_instances }}
      memory: ${{ steps.load-config.outputs.memory }}
      cpu: ${{ steps.load-config.outputs.cpu }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set environment based on branch or input
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/uat" ]]; then
            echo "environment=uat" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi
      
      - name: Set application based on repository
        id: set-app
        run: |
          # Extract application name from repository name
          REPO_NAME="${{ github.repository }}"
          REPO_PART=$(echo $REPO_NAME | cut -d'/' -f2)
          
          if [[ "$REPO_PART" == *"giortech"* ]]; then
            echo "application=giortech" >> $GITHUB_OUTPUT
          elif [[ "$REPO_PART" == *"waspwallet"* ]]; then
            echo "application=waspwallet" >> $GITHUB_OUTPUT
          elif [[ "$REPO_PART" == *"academyaxis"* ]]; then
            echo "application=academyaxis" >> $GITHUB_OUTPUT
          else
            echo "application=giortech" >> $GITHUB_OUTPUT  # Default fallback
          fi
      
      - name: Load configuration
        id: load-config
        run: |
          APP="${{ steps.set-app.outputs.application }}"
          ENV="${{ steps.set-env.outputs.environment }}"
          
          echo "Loading config for $APP in $ENV environment"
          
          # Configuration mapping based on your project knowledge
          case "$APP-$ENV" in
            "giortech-dev")
              echo "project_id=giortech-dev-project" >> $GITHUB_OUTPUT
              echo "project_number=653675374627" >> $GITHUB_OUTPUT
              echo "service_name=giortech-dev" >> $GITHUB_OUTPUT
              ;;
            "giortech-uat")
              echo "project_id=giortech-uat-project" >> $GITHUB_OUTPUT
              echo "project_number=28962750525" >> $GITHUB_OUTPUT
              echo "service_name=giortech-uat" >> $GITHUB_OUTPUT
              ;;
            "giortech-prod")
              echo "project_id=giortech-prod-project" >> $GITHUB_OUTPUT
              echo "project_number=371831144642" >> $GITHUB_OUTPUT
              echo "service_name=giortech-prod" >> $GITHUB_OUTPUT
              ;;
            "waspwallet-dev")
              echo "project_id=waspwallet-dev-project" >> $GITHUB_OUTPUT
              echo "project_number=260301647000" >> $GITHUB_OUTPUT
              echo "service_name=waspwallet-dev" >> $GITHUB_OUTPUT
              ;;
            "waspwallet-uat")
              echo "project_id=waspwallet-uat-project" >> $GITHUB_OUTPUT
              echo "project_number=875164789138" >> $GITHUB_OUTPUT
              echo "service_name=waspwallet-uat" >> $GITHUB_OUTPUT
              ;;
            "waspwallet-prod")
              echo "project_id=waspwallet-prod-project" >> $GITHUB_OUTPUT
              echo "project_number=142392555937" >> $GITHUB_OUTPUT
              echo "service_name=waspwallet-prod" >> $GITHUB_OUTPUT
              ;;
            "academyaxis-dev")
              echo "project_id=academyaxis-dev-project" >> $GITHUB_OUTPUT
              echo "project_number=1052274887859" >> $GITHUB_OUTPUT
              echo "service_name=academyaxis-dev" >> $GITHUB_OUTPUT
              ;;
            "academyaxis-uat")
              echo "project_id=academyaxis-uat-project" >> $GITHUB_OUTPUT
              echo "project_number=415071431590" >> $GITHUB_OUTPUT
              echo "service_name=academyaxis-uat" >> $GITHUB_OUTPUT
              ;;
            "academyaxis-prod")
              echo "project_id=academyaxis-prod-project" >> $GITHUB_OUTPUT
              echo "project_number=552816176477" >> $GITHUB_OUTPUT
              echo "service_name=academyaxis-prod" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "::error::Unknown application-environment combination: $APP-$ENV"
              exit 1
              ;;
          esac
          
          # Common configuration
          echo "region=us-central1" >> $GITHUB_OUTPUT
          echo "memory=512Mi" >> $GITHUB_OUTPUT
          echo "cpu=1" >> $GITHUB_OUTPUT
          echo "min_instances=0" >> $GITHUB_OUTPUT
          echo "max_instances=10" >> $GITHUB_OUTPUT

  get-workload-identity:
    needs: determine-context
    runs-on: ubuntu-latest
    outputs:
      wi_provider: ${{ steps.set-wi.outputs.wi_provider }}
      sa_email: ${{ steps.set-wi.outputs.sa_email }}
    
    steps:
      - name: Set Workload Identity values
        id: set-wi
        run: |
          PROJECT_NUMBER="${{ needs.determine-context.outputs.project_number }}"
          PROJECT_ID="${{ needs.determine-context.outputs.project_id }}"
          
          echo "wi_provider=projects/${PROJECT_NUMBER}/locations/global/workloadIdentityPools/github-pool/providers/github-provider" >> $GITHUB_OUTPUT
          echo "sa_email=github-actions-sa@${PROJECT_ID}.iam.gserviceaccount.com" >> $GITHUB_OUTPUT

  deploy:
    needs: [determine-context, get-workload-identity]
    runs-on: ubuntu-latest
    timeout-minutes: 20
    
    permissions:
      contents: 'read'
      id-token: 'write'
    
    environment: ${{ needs.determine-context.outputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ needs.get-workload-identity.outputs.wi_provider }}
          service_account: ${{ needs.get-workload-identity.outputs.sa_email }}
      
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ needs.determine-context.outputs.project_id }}
      
      - name: Verify GCP connection
        run: |
          echo "üîç Testing GCP connection:"
          gcloud auth list
          gcloud config list project
          
          echo "üìã Current project info:"
          gcloud projects describe ${{ needs.determine-context.outputs.project_id }}
      
      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker us-central1-docker.pkg.dev
      
      - name: Build and Push Docker Image
        run: |
          PROJECT_ID="${{ needs.determine-context.outputs.project_id }}"
          SERVICE_NAME="${{ needs.determine-context.outputs.service_name }}"
          APP="${{ needs.determine-context.outputs.application }}"
          ENV="${{ needs.determine-context.outputs.environment }}"
          
          # Build image with proper tagging
          IMAGE_TAG="us-central1-docker.pkg.dev/$PROJECT_ID/$APP-$ENV/app:${{ github.sha }}"
          
          echo "üèóÔ∏è Building Docker image: $IMAGE_TAG"
          docker build -t "$IMAGE_TAG" .
          
          echo "üì§ Pushing Docker image..."
          docker push "$IMAGE_TAG"
      
      - name: Deploy to Cloud Run with Firebase Support
        run: |
          PROJECT_ID="${{ needs.determine-context.outputs.project_id }}"
          SERVICE_NAME="${{ needs.determine-context.outputs.service_name }}"
          APP="${{ needs.determine-context.outputs.application }}"
          ENV="${{ needs.determine-context.outputs.environment }}"
          IMAGE_TAG="us-central1-docker.pkg.dev/$PROJECT_ID/$APP-$ENV/app:${{ github.sha }}"
          
          echo "üöÄ Deploying to Cloud Run..."
          gcloud run deploy $SERVICE_NAME \
            --image="$IMAGE_TAG" \
            --project=$PROJECT_ID \
            --region=${{ needs.determine-context.outputs.region }} \
            --platform=managed \
            --allow-unauthenticated \
            --set-env-vars="GOOGLE_CLOUD_PROJECT=$PROJECT_ID,NODE_ENV=$ENV,ENVIRONMENT=$ENV" \
            --memory=${{ needs.determine-context.outputs.memory }} \
            --cpu=${{ needs.determine-context.outputs.cpu }} \
            --min-instances=${{ needs.determine-context.outputs.min_instances }} \
            --max-instances=${{ needs.determine-context.outputs.max_instances }} \
            --timeout=300s \
            --execution-environment=gen2
      
      - name: Test Firebase Connection Post-Deploy
        run: |
          echo "üß™ Testing deployed service with Firebase..."
          
          # Get service URL
          SERVICE_URL=$(gcloud run services describe ${{ needs.determine-context.outputs.service_name }} \
            --project=${{ needs.determine-context.outputs.project_id }} \
            --region=${{ needs.determine-context.outputs.region }} \
            --format="get(status.url)")
          
          echo "üåê Service URL: $SERVICE_URL"
          
          # Wait for service to be ready
          echo "‚è≥ Waiting for service to be ready..."
          sleep 30
          
          # Test health endpoint (if available)
          if curl -f "$SERVICE_URL/health" 2>/dev/null; then
            echo "‚úÖ Health check passed"
          else
            echo "‚ö†Ô∏è Health endpoint not available (this is normal if not implemented)"
          fi
          
          # Test basic connectivity
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$SERVICE_URL" || echo "TIMEOUT")
          echo "üìä Service response status: $HTTP_STATUS"
      
      - name: Deploy Summary
        run: |
          echo "üéâ Deployment completed successfully!"
          echo "üìã Summary:"
          echo "  Application: ${{ needs.determine-context.outputs.application }}"
          echo "  Environment: ${{ needs.determine-context.outputs.environment }}"
          echo "  Project: ${{ needs.determine-context.outputs.project_id }}"
          echo "  Service: ${{ needs.determine-context.outputs.service_name }}"
          echo "  Region: ${{ needs.determine-context.outputs.region }}"
          echo "  Image: us-central1-docker.pkg.dev/${{ needs.determine-context.outputs.project_id }}/${{ needs.determine-context.outputs.application }}-${{ needs.determine-context.outputs.environment }}/app:${{ github.sha }}"
          echo "  Firebase Enabled: ‚úÖ"